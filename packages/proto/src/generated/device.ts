// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: device.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { wrappers } from "protobufjs";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "device";

/** Core device entity used in responses. */
export interface Device {
  id: string;
  userId: string;
  name: string;
  externalId: string;
  profileId: string;
  protocol: string;
  groupId?: string | undefined;
  connectionConfig: string;
}

/** Request to create a device */
export interface CreateDeviceRequest {
  /** API Gateway will inject this field from the JWT token */
  userId: string;
  name: string;
  externalId: string;
  protocol: string;
  groupId?: string | undefined;
  profileId: string;
  /** Flexible structure for arbitrary JSON data */
  connectionConfig: string;
}

/** Request to get a single device */
export interface GetDeviceRequest {
  id: string;
  /** Used for access control checks */
  userId: string;
}

/** Request to retrieve a list of devices */
export interface FindDevicesRequest {
  /** Mandatory: restricts search to this user's devices */
  userId: string;
  page?: number | undefined;
  limit?:
    | number
    | undefined;
  /** Filter by protocol */
  protocol?:
    | string
    | undefined;
  /** Filter by group */
  groupId?: string | undefined;
}

/** Response containing a list of devices */
export interface FindDevicesResponse {
  devices: Device[];
  /** Total count of found devices (for pagination) */
  total: number;
}

/** Request to update a device */
export interface UpdateDeviceRequest {
  id: string;
  /** Used for access control checks */
  userId: string;
  /**
   * Use wrappers for fields that can be updated.
   * This allows distinguishing between "undefined" (field is not being updated)
   * and "empty string/value" (field should be cleared).
   */
  name?:
    | string
    | undefined;
  /**
   * For group_id, we need the ability to set it to null.
   * StringValue wrapper is perfect here. If an empty string (or specific value)
   * is passed within the wrapper, we can interpret it as "remove from group".
   */
  groupId?: string | undefined;
}

/** Request to delete a device */
export interface DeleteDeviceRequest {
  id: string;
  /** Used for access control checks */
  userId: string;
}

export interface Group {
  id: string;
  userId: string;
  name: string;
  description?:
    | string
    | undefined;
  /** Creation timestamp */
  createdAt: Timestamp | undefined;
  devicesCount: number;
}

export interface CreateGroupRequest {
  /** Extracted from JWT */
  userId: string;
  name: string;
  description?: string | undefined;
}

export interface GetGroupRequest {
  id: string;
  /** For permission check */
  userId: string;
}

export interface FindGroupsRequest {
  userId: string;
  page?: number | undefined;
  limit?: number | undefined;
}

export interface FindGroupsResponse {
  groups: Group[];
  total: number;
}

export interface UpdateGroupRequest {
  id: string;
  userId: string;
  /** Using optional to distinguish between "undefined" (do not update) and empty string */
  name?: string | undefined;
  description?: string | undefined;
}

export interface DeleteGroupRequest {
  id: string;
  userId: string;
}

export interface DeleteGroupResponse {
  success: boolean;
}

export interface SearchProfilesRequest {
  /** Search string (e.g., "sonoff") */
  query: string;
  /** Filter (e.g., "WIFI", "ZIGBEE") - empty string if not selected */
  protocol: string;
  /** Number of records to return (default: 20) */
  limit: number;
}

export interface SearchProfilesResponse {
  profiles: ProfileResponse[];
}

export interface FindOneProfileRequest {
  id: string;
}

export interface ProfileResponse {
  id: string;
  name: string;
  vendor: string;
  protocol: string;
  description: string;
  /**
   * Mappings are transferred as a Structure (JSON).
   * For Search operations, this field can be left empty to save bandwidth.
   */
  mappings: { [key: string]: any } | undefined;
}

export const DEVICE_PACKAGE_NAME = "device";

wrappers[".google.protobuf.Struct"] = { fromObject: Struct.wrap, toObject: Struct.unwrap } as any;

/**
 * Service implemented in DeviceManagementService
 * and called from the API Gateway.
 */

export interface DeviceManagementServiceClient {
  /** Creates a new device */

  createDevice(request: CreateDeviceRequest): Observable<Device>;

  /** Retrieves a device by ID */

  getDevice(request: GetDeviceRequest): Observable<Device>;

  /** Retrieves a list of devices with filtering and pagination */

  findDevices(request: FindDevicesRequest): Observable<FindDevicesResponse>;

  /** Updates device data (partial update) */

  updateDevice(request: UpdateDeviceRequest): Observable<Device>;

  /** Deletes a device */

  deleteDevice(request: DeleteDeviceRequest): Observable<Empty>;

  /** Creates a new device group */

  createGroup(request: CreateGroupRequest): Observable<Group>;

  /** Retrieves a single group by ID */

  getGroup(request: GetGroupRequest): Observable<Group>;

  /** Retrieves a list of groups with pagination */

  findGroups(request: FindGroupsRequest): Observable<FindGroupsResponse>;

  /** Updates group details */

  updateGroup(request: UpdateGroupRequest): Observable<Group>;

  /** Deletes a group */

  deleteGroup(request: DeleteGroupRequest): Observable<DeleteGroupResponse>;
}

/**
 * Service implemented in DeviceManagementService
 * and called from the API Gateway.
 */

export interface DeviceManagementServiceController {
  /** Creates a new device */

  createDevice(request: CreateDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Retrieves a device by ID */

  getDevice(request: GetDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Retrieves a list of devices with filtering and pagination */

  findDevices(
    request: FindDevicesRequest,
  ): Promise<FindDevicesResponse> | Observable<FindDevicesResponse> | FindDevicesResponse;

  /** Updates device data (partial update) */

  updateDevice(request: UpdateDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Deletes a device */

  deleteDevice(request: DeleteDeviceRequest): void;

  /** Creates a new device group */

  createGroup(request: CreateGroupRequest): Promise<Group> | Observable<Group> | Group;

  /** Retrieves a single group by ID */

  getGroup(request: GetGroupRequest): Promise<Group> | Observable<Group> | Group;

  /** Retrieves a list of groups with pagination */

  findGroups(
    request: FindGroupsRequest,
  ): Promise<FindGroupsResponse> | Observable<FindGroupsResponse> | FindGroupsResponse;

  /** Updates group details */

  updateGroup(request: UpdateGroupRequest): Promise<Group> | Observable<Group> | Group;

  /** Deletes a group */

  deleteGroup(
    request: DeleteGroupRequest,
  ): Promise<DeleteGroupResponse> | Observable<DeleteGroupResponse> | DeleteGroupResponse;
}

export function DeviceManagementServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createDevice",
      "getDevice",
      "findDevices",
      "updateDevice",
      "deleteDevice",
      "createGroup",
      "getGroup",
      "findGroups",
      "updateGroup",
      "deleteGroup",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("DeviceManagementService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("DeviceManagementService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const DEVICE_MANAGEMENT_SERVICE_NAME = "DeviceManagementService";

export interface ProfilesServiceClient {
  /** Search profiles (e.g., for UI dropdown/autocomplete) */

  search(request: SearchProfilesRequest): Observable<SearchProfilesResponse>;

  /** Retrieve a single profile (for validation or detailed view) */

  findOne(request: FindOneProfileRequest): Observable<ProfileResponse>;
}

export interface ProfilesServiceController {
  /** Search profiles (e.g., for UI dropdown/autocomplete) */

  search(
    request: SearchProfilesRequest,
  ): Promise<SearchProfilesResponse> | Observable<SearchProfilesResponse> | SearchProfilesResponse;

  /** Retrieve a single profile (for validation or detailed view) */

  findOne(request: FindOneProfileRequest): Promise<ProfileResponse> | Observable<ProfileResponse> | ProfileResponse;
}

export function ProfilesServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["search", "findOne"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProfilesService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProfilesService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PROFILES_SERVICE_NAME = "ProfilesService";
