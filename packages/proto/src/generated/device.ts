// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: device.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { wrappers } from "protobufjs";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "device";

export enum DeviceProtocol {
  PROTOCOL_UNSPECIFIED = 0,
  MQTT = 1,
  ZIGBEE = 2,
  TUYA = 3,
  UNRECOGNIZED = -1,
}

export enum DeviceStatus {
  STATUS_UNSPECIFIED = 0,
  ONLINE = 1,
  OFFLINE = 2,
  UNRECOGNIZED = -1,
}

/** Основная сущность устройства. Используется в ответах. */
export interface Device {
  id: string;
  userId: string;
  name: string;
  protocol: DeviceProtocol;
  status: DeviceStatus;
  groupId?: string | undefined;
  connectionConfig: { [key: string]: any } | undefined;
  createdAt: Timestamp | undefined;
  updatedAt: Timestamp | undefined;
}

/** Запрос на создание устройства */
export interface CreateDeviceRequest {
  /** API Gateway добавит это поле из JWT токена */
  userId: string;
  name: string;
  externalId: string;
  protocol: DeviceProtocol;
  groupId?:
    | string
    | undefined;
  /** Гибкая структура для любых JSON данных */
  connectionConfig: { [key: string]: any } | undefined;
}

/** Запрос на получение одного устройства */
export interface GetDeviceRequest {
  id: string;
  /** Для проверки прав доступа */
  userId: string;
}

/** Запрос на получение списка устройств */
export interface FindDevicesRequest {
  /** Обязательно, чтобы искать устройства только этого пользователя */
  userId: string;
  page?: number | undefined;
  limit?:
    | number
    | undefined;
  /** Фильтр по протоколу */
  protocol?:
    | DeviceProtocol
    | undefined;
  /** Фильтр по группе */
  groupId?: string | undefined;
}

/** Ответ со списком устройств */
export interface FindDevicesResponse {
  devices: Device[];
  /** Общее количество найденных устройств для пагинации */
  total: number;
}

/** Запрос на обновление устройства */
export interface UpdateDeviceRequest {
  id: string;
  /** Для проверки прав доступа */
  userId: string;
  /**
   * Используем обертки (wrappers) для полей, которые можно обновлять.
   * Это позволяет нам отличить "не передано" (поле не обновляется)
   * от "передана пустая строка".
   */
  name?:
    | string
    | undefined;
  /**
   * Для groupId нам нужно иметь возможность установить его в null.
   * Обертка StringValue здесь идеально подходит. Если передать wrapper
   * с пустым string, мы можем интерпретировать это как "убрать из группы".
   */
  groupId?: string | undefined;
}

/** Запрос на удаление устройства */
export interface DeleteDeviceRequest {
  id: string;
  /** Для проверки прав доступа */
  userId: string;
}

export interface SearchProfilesRequest {
  /** Поисковая строка ("sonoff") */
  query: string;
  /** Фильтр ("WIFI", "ZIGBEE") - пустая строка если не выбран */
  protocol: string;
  /** Сколько записей вернуть (по умолчанию 20) */
  limit: number;
}

export interface SearchProfilesResponse {
  profiles: ProfileResponse[];
}

export interface FindOneProfileRequest {
  id: string;
}

export interface ProfileResponse {
  id: string;
  name: string;
  vendor: string;
  protocol: string;
  description: string;
  /**
   * Mappings передаем как структуру (JSON),
   * но для поиска (Search) это поле можно оставлять пустым для экономии трафика
   */
  mappings: { [key: string]: any } | undefined;
}

export const DEVICE_PACKAGE_NAME = "device";

wrappers[".google.protobuf.Struct"] = { fromObject: Struct.wrap, toObject: Struct.unwrap } as any;

/**
 * Сервис, который будет реализован в DeviceManagementService
 * и вызываться из API Gateway.
 */

export interface DeviceManagementServiceClient {
  /** Создает новое устройство */

  createDevice(request: CreateDeviceRequest): Observable<Device>;

  /** Получает устройство по ID */

  getDevice(request: GetDeviceRequest): Observable<Device>;

  /** Получает список устройств с фильтрацией и пагинацией */

  findDevices(request: FindDevicesRequest): Observable<FindDevicesResponse>;

  /** Обновляет данные устройства (частичное обновление) */

  updateDevice(request: UpdateDeviceRequest): Observable<Device>;

  /** Удаляет устройство */

  deleteDevice(request: DeleteDeviceRequest): Observable<Empty>;
}

/**
 * Сервис, который будет реализован в DeviceManagementService
 * и вызываться из API Gateway.
 */

export interface DeviceManagementServiceController {
  /** Создает новое устройство */

  createDevice(request: CreateDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Получает устройство по ID */

  getDevice(request: GetDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Получает список устройств с фильтрацией и пагинацией */

  findDevices(
    request: FindDevicesRequest,
  ): Promise<FindDevicesResponse> | Observable<FindDevicesResponse> | FindDevicesResponse;

  /** Обновляет данные устройства (частичное обновление) */

  updateDevice(request: UpdateDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Удаляет устройство */

  deleteDevice(request: DeleteDeviceRequest): void;
}

export function DeviceManagementServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createDevice", "getDevice", "findDevices", "updateDevice", "deleteDevice"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("DeviceManagementService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("DeviceManagementService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const DEVICE_MANAGEMENT_SERVICE_NAME = "DeviceManagementService";

export interface ProfilesServiceClient {
  /** Поиск профилей (для выпадающего списка) */

  search(request: SearchProfilesRequest): Observable<SearchProfilesResponse>;

  /** Получение одного профиля (для валидации или просмотра деталей) */

  findOne(request: FindOneProfileRequest): Observable<ProfileResponse>;
}

export interface ProfilesServiceController {
  /** Поиск профилей (для выпадающего списка) */

  search(
    request: SearchProfilesRequest,
  ): Promise<SearchProfilesResponse> | Observable<SearchProfilesResponse> | SearchProfilesResponse;

  /** Получение одного профиля (для валидации или просмотра деталей) */

  findOne(request: FindOneProfileRequest): Promise<ProfileResponse> | Observable<ProfileResponse> | ProfileResponse;
}

export function ProfilesServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["search", "findOne"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProfilesService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProfilesService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PROFILES_SERVICE_NAME = "ProfilesService";
