// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.0
// source: device.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { wrappers } from "protobufjs";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";
import { Struct } from "./google/protobuf/struct";

export const protobufPackage = "device";

export enum DeviceProtocol {
  PROTOCOL_UNSPECIFIED = 0,
  MQTT = 1,
  ZIGBEE = 2,
  TUYA = 3,
  UNRECOGNIZED = -1,
}

/** Core device entity used in responses. */
export interface Device {
  id: string;
  userId: string;
  name: string;
  protocol: DeviceProtocol;
  groupId?:
    | string
    | undefined;
  /**
   * google.protobuf.Timestamp created_at = 7;
   * google.protobuf.Timestamp updated_at = 8;
   */
  connectionConfig: { [key: string]: any } | undefined;
}

/** Request to create a device */
export interface CreateDeviceRequest {
  /** API Gateway will inject this field from the JWT token */
  userId: string;
  name: string;
  externalId: string;
  protocol: DeviceProtocol;
  groupId?: string | undefined;
  profileId: string;
  /** Flexible structure for arbitrary JSON data */
  connectionConfig: { [key: string]: any } | undefined;
}

/** Request to get a single device */
export interface GetDeviceRequest {
  id: string;
  /** Used for access control checks */
  userId: string;
}

/** Request to retrieve a list of devices */
export interface FindDevicesRequest {
  /** Mandatory: restricts search to this user's devices */
  userId: string;
  page?: number | undefined;
  limit?:
    | number
    | undefined;
  /** Filter by protocol */
  protocol?:
    | DeviceProtocol
    | undefined;
  /** Filter by group */
  groupId?: string | undefined;
}

/** Response containing a list of devices */
export interface FindDevicesResponse {
  devices: Device[];
  /** Total count of found devices (for pagination) */
  total: number;
}

/** Request to update a device */
export interface UpdateDeviceRequest {
  id: string;
  /** Used for access control checks */
  userId: string;
  /**
   * Use wrappers for fields that can be updated.
   * This allows distinguishing between "undefined" (field is not being updated)
   * and "empty string/value" (field should be cleared).
   */
  name?:
    | string
    | undefined;
  /**
   * For group_id, we need the ability to set it to null.
   * StringValue wrapper is perfect here. If an empty string (or specific value)
   * is passed within the wrapper, we can interpret it as "remove from group".
   */
  groupId?: string | undefined;
}

/** Request to delete a device */
export interface DeleteDeviceRequest {
  id: string;
  /** Used for access control checks */
  userId: string;
}

export interface SearchProfilesRequest {
  /** Search string (e.g., "sonoff") */
  query: string;
  /** Filter (e.g., "WIFI", "ZIGBEE") - empty string if not selected */
  protocol: string;
  /** Number of records to return (default: 20) */
  limit: number;
}

export interface SearchProfilesResponse {
  profiles: ProfileResponse[];
}

export interface FindOneProfileRequest {
  id: string;
}

export interface ProfileResponse {
  id: string;
  name: string;
  vendor: string;
  protocol: string;
  description: string;
  /**
   * Mappings are transferred as a Structure (JSON).
   * For Search operations, this field can be left empty to save bandwidth.
   */
  mappings: { [key: string]: any } | undefined;
}

export const DEVICE_PACKAGE_NAME = "device";

wrappers[".google.protobuf.Struct"] = { fromObject: Struct.wrap, toObject: Struct.unwrap } as any;

/**
 * Service implemented in DeviceManagementService
 * and called from the API Gateway.
 */

export interface DeviceManagementServiceClient {
  /** Creates a new device */

  createDevice(request: CreateDeviceRequest): Observable<Device>;

  /** Retrieves a device by ID */

  getDevice(request: GetDeviceRequest): Observable<Device>;

  /** Retrieves a list of devices with filtering and pagination */

  findDevices(request: FindDevicesRequest): Observable<FindDevicesResponse>;

  /** Updates device data (partial update) */

  updateDevice(request: UpdateDeviceRequest): Observable<Device>;

  /** Deletes a device */

  deleteDevice(request: DeleteDeviceRequest): Observable<Empty>;
}

/**
 * Service implemented in DeviceManagementService
 * and called from the API Gateway.
 */

export interface DeviceManagementServiceController {
  /** Creates a new device */

  createDevice(request: CreateDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Retrieves a device by ID */

  getDevice(request: GetDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Retrieves a list of devices with filtering and pagination */

  findDevices(
    request: FindDevicesRequest,
  ): Promise<FindDevicesResponse> | Observable<FindDevicesResponse> | FindDevicesResponse;

  /** Updates device data (partial update) */

  updateDevice(request: UpdateDeviceRequest): Promise<Device> | Observable<Device> | Device;

  /** Deletes a device */

  deleteDevice(request: DeleteDeviceRequest): void;
}

export function DeviceManagementServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createDevice", "getDevice", "findDevices", "updateDevice", "deleteDevice"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("DeviceManagementService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("DeviceManagementService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const DEVICE_MANAGEMENT_SERVICE_NAME = "DeviceManagementService";

export interface ProfilesServiceClient {
  /** Search profiles (e.g., for UI dropdown/autocomplete) */

  search(request: SearchProfilesRequest): Observable<SearchProfilesResponse>;

  /** Retrieve a single profile (for validation or detailed view) */

  findOne(request: FindOneProfileRequest): Observable<ProfileResponse>;
}

export interface ProfilesServiceController {
  /** Search profiles (e.g., for UI dropdown/autocomplete) */

  search(
    request: SearchProfilesRequest,
  ): Promise<SearchProfilesResponse> | Observable<SearchProfilesResponse> | SearchProfilesResponse;

  /** Retrieve a single profile (for validation or detailed view) */

  findOne(request: FindOneProfileRequest): Promise<ProfileResponse> | Observable<ProfileResponse> | ProfileResponse;
}

export function ProfilesServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["search", "findOne"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProfilesService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProfilesService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PROFILES_SERVICE_NAME = "ProfilesService";
